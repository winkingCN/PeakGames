using System;
using Org.BouncyCastle.Crypto;

public class LBGLBLFLLJH : PHFBFDEAHMD
{
	private byte HJMBDGKAOBP;

	private byte IDHLPOFDLKJ;

	private byte[] MBIJHANOCOC;

	private byte IBBBMACIBGK;

	private byte[] KHMOPAMHALB;

	private byte[] DEJOMANPMNN;

	private byte[] IOANFHFGPJK;

	private byte CMJGCHCINDK;

	private byte DPGEOPKDNPM;

	private byte JLBGELNHGPO;

	private byte JLNKLCPNCJH;

	public virtual string KFKMEPMEBND
	{
		get
		{
			return "VMPC-MAC";
		}
	}

	public virtual int LCNOFBMOHHM(byte[] BILGCJNPJGJ, int EMAKNGBIFDC)
	{
		for (int i = 1; i < 25; i++)
		{
			IBBBMACIBGK = MBIJHANOCOC[(IBBBMACIBGK + MBIJHANOCOC[IDHLPOFDLKJ & 0xFF]) & 0xFF];
			JLNKLCPNCJH = MBIJHANOCOC[(JLNKLCPNCJH + JLBGELNHGPO + i) & 0xFF];
			JLBGELNHGPO = MBIJHANOCOC[(JLBGELNHGPO + DPGEOPKDNPM + i) & 0xFF];
			DPGEOPKDNPM = MBIJHANOCOC[(DPGEOPKDNPM + CMJGCHCINDK + i) & 0xFF];
			CMJGCHCINDK = MBIJHANOCOC[(CMJGCHCINDK + IBBBMACIBGK + i) & 0xFF];
			KHMOPAMHALB[HJMBDGKAOBP & 0x1F] = (byte)(KHMOPAMHALB[HJMBDGKAOBP & 0x1F] ^ CMJGCHCINDK);
			KHMOPAMHALB[(HJMBDGKAOBP + 1) & 0x1F] = (byte)(KHMOPAMHALB[(HJMBDGKAOBP + 1) & 0x1F] ^ DPGEOPKDNPM);
			KHMOPAMHALB[(HJMBDGKAOBP + 2) & 0x1F] = (byte)(KHMOPAMHALB[(HJMBDGKAOBP + 2) & 0x1F] ^ JLBGELNHGPO);
			KHMOPAMHALB[(HJMBDGKAOBP + 3) & 0x1F] = (byte)(KHMOPAMHALB[(HJMBDGKAOBP + 3) & 0x1F] ^ JLNKLCPNCJH);
			HJMBDGKAOBP = (byte)((uint)(HJMBDGKAOBP + 4) & 0x1Fu);
			byte b = MBIJHANOCOC[IDHLPOFDLKJ & 0xFF];
			MBIJHANOCOC[IDHLPOFDLKJ & 0xFF] = MBIJHANOCOC[IBBBMACIBGK & 0xFF];
			MBIJHANOCOC[IBBBMACIBGK & 0xFF] = b;
			IDHLPOFDLKJ = (byte)((uint)(IDHLPOFDLKJ + 1) & 0xFFu);
		}
		for (int j = 0; j < 768; j++)
		{
			IBBBMACIBGK = MBIJHANOCOC[(IBBBMACIBGK + MBIJHANOCOC[j & 0xFF] + KHMOPAMHALB[j & 0x1F]) & 0xFF];
			byte b2 = MBIJHANOCOC[j & 0xFF];
			MBIJHANOCOC[j & 0xFF] = MBIJHANOCOC[IBBBMACIBGK & 0xFF];
			MBIJHANOCOC[IBBBMACIBGK & 0xFF] = b2;
		}
		byte[] array = new byte[20];
		for (int k = 0; k < 20; k++)
		{
			IBBBMACIBGK = MBIJHANOCOC[(IBBBMACIBGK + MBIJHANOCOC[k & 0xFF]) & 0xFF];
			array[k] = MBIJHANOCOC[(MBIJHANOCOC[MBIJHANOCOC[IBBBMACIBGK & 0xFF] & 0xFF] + 1) & 0xFF];
			byte b3 = MBIJHANOCOC[k & 0xFF];
			MBIJHANOCOC[k & 0xFF] = MBIJHANOCOC[IBBBMACIBGK & 0xFF];
			MBIJHANOCOC[IBBBMACIBGK & 0xFF] = b3;
		}
		Array.Copy(array, 0, BILGCJNPJGJ, EMAKNGBIFDC, array.Length);
		OMOKOKFNBKI();
		return array.Length;
	}

	public virtual int BKGLOJPPBIG()
	{
		return 20;
	}

	public virtual void DIOELAHNLKJ(IGMAJHKIIPK IJJHBEECMBP)
	{
		if (!(IJJHBEECMBP is CHCELGDKEJG))
		{
			throw new ArgumentException("VMPC-MAC Init parameters must include an IV", "parameters");
		}
		CHCELGDKEJG cHCELGDKEJG = (CHCELGDKEJG)IJJHBEECMBP;
		JEMNCGMEABF jEMNCGMEABF = (JEMNCGMEABF)cHCELGDKEJG.KPJHHAAOFOH;
		if (!(cHCELGDKEJG.KPJHHAAOFOH is JEMNCGMEABF))
		{
			throw new ArgumentException("VMPC-MAC Init parameters must include a key", "parameters");
		}
		DEJOMANPMNN = cHCELGDKEJG.OLAEDCABKDH();
		if (DEJOMANPMNN == null || DEJOMANPMNN.Length < 1 || DEJOMANPMNN.Length > 768)
		{
			throw new ArgumentException("VMPC-MAC requires 1 to 768 bytes of IV", "parameters");
		}
		IOANFHFGPJK = jEMNCGMEABF.MEGBFHFMBFI();
		OMOKOKFNBKI();
	}

	private void GDIDDKLLJJD(byte[] EGJBACEEHAK, byte[] MIMCBAKIPJC)
	{
		IBBBMACIBGK = 0;
		MBIJHANOCOC = new byte[256];
		for (int i = 0; i < 256; i++)
		{
			MBIJHANOCOC[i] = (byte)i;
		}
		for (int j = 0; j < 768; j++)
		{
			IBBBMACIBGK = MBIJHANOCOC[(IBBBMACIBGK + MBIJHANOCOC[j & 0xFF] + EGJBACEEHAK[j % EGJBACEEHAK.Length]) & 0xFF];
			byte b = MBIJHANOCOC[j & 0xFF];
			MBIJHANOCOC[j & 0xFF] = MBIJHANOCOC[IBBBMACIBGK & 0xFF];
			MBIJHANOCOC[IBBBMACIBGK & 0xFF] = b;
		}
		for (int k = 0; k < 768; k++)
		{
			IBBBMACIBGK = MBIJHANOCOC[(IBBBMACIBGK + MBIJHANOCOC[k & 0xFF] + MIMCBAKIPJC[k % MIMCBAKIPJC.Length]) & 0xFF];
			byte b2 = MBIJHANOCOC[k & 0xFF];
			MBIJHANOCOC[k & 0xFF] = MBIJHANOCOC[IBBBMACIBGK & 0xFF];
			MBIJHANOCOC[IBBBMACIBGK & 0xFF] = b2;
		}
		IDHLPOFDLKJ = 0;
	}

	public virtual void OMOKOKFNBKI()
	{
		GDIDDKLLJJD(IOANFHFGPJK, DEJOMANPMNN);
		HJMBDGKAOBP = (CMJGCHCINDK = (DPGEOPKDNPM = (JLBGELNHGPO = (JLNKLCPNCJH = (IDHLPOFDLKJ = 0)))));
		KHMOPAMHALB = new byte[32];
		for (int i = 0; i < 32; i++)
		{
			KHMOPAMHALB[i] = 0;
		}
	}

	public virtual void BPAJGOINFNL(byte MOPCLEEGDFB)
	{
		IBBBMACIBGK = MBIJHANOCOC[(IBBBMACIBGK + MBIJHANOCOC[IDHLPOFDLKJ & 0xFF]) & 0xFF];
		byte b = (byte)(MOPCLEEGDFB ^ MBIJHANOCOC[(MBIJHANOCOC[MBIJHANOCOC[IBBBMACIBGK & 0xFF] & 0xFF] + 1) & 0xFF]);
		JLNKLCPNCJH = MBIJHANOCOC[(JLNKLCPNCJH + JLBGELNHGPO) & 0xFF];
		JLBGELNHGPO = MBIJHANOCOC[(JLBGELNHGPO + DPGEOPKDNPM) & 0xFF];
		DPGEOPKDNPM = MBIJHANOCOC[(DPGEOPKDNPM + CMJGCHCINDK) & 0xFF];
		CMJGCHCINDK = MBIJHANOCOC[(CMJGCHCINDK + IBBBMACIBGK + b) & 0xFF];
		KHMOPAMHALB[HJMBDGKAOBP & 0x1F] = (byte)(KHMOPAMHALB[HJMBDGKAOBP & 0x1F] ^ CMJGCHCINDK);
		KHMOPAMHALB[(HJMBDGKAOBP + 1) & 0x1F] = (byte)(KHMOPAMHALB[(HJMBDGKAOBP + 1) & 0x1F] ^ DPGEOPKDNPM);
		KHMOPAMHALB[(HJMBDGKAOBP + 2) & 0x1F] = (byte)(KHMOPAMHALB[(HJMBDGKAOBP + 2) & 0x1F] ^ JLBGELNHGPO);
		KHMOPAMHALB[(HJMBDGKAOBP + 3) & 0x1F] = (byte)(KHMOPAMHALB[(HJMBDGKAOBP + 3) & 0x1F] ^ JLNKLCPNCJH);
		HJMBDGKAOBP = (byte)((uint)(HJMBDGKAOBP + 4) & 0x1Fu);
		byte b2 = MBIJHANOCOC[IDHLPOFDLKJ & 0xFF];
		MBIJHANOCOC[IDHLPOFDLKJ & 0xFF] = MBIJHANOCOC[IBBBMACIBGK & 0xFF];
		MBIJHANOCOC[IBBBMACIBGK & 0xFF] = b2;
		IDHLPOFDLKJ = (byte)((uint)(IDHLPOFDLKJ + 1) & 0xFFu);
	}

	public virtual void GONEEEFEDGF(byte[] MOPCLEEGDFB, int ELICNEDIBGB, int NBEDPKHALCN)
	{
		if (ELICNEDIBGB + NBEDPKHALCN > MOPCLEEGDFB.Length)
		{
			throw new DataLengthException("input buffer too short");
		}
		for (int i = 0; i < NBEDPKHALCN; i++)
		{
			BPAJGOINFNL(MOPCLEEGDFB[ELICNEDIBGB + i]);
		}
	}
}
